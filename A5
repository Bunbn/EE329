#include "main.h"
#include "keypad.h"
#include "DELAY.h"
#include <math.h>

int main(void)
{
  uint8_t index=0;
  uint8_t keypadnum[3]={0,0,0};
  uint32_t voltage=0;
  uint8_t keypad=0;
  uint8_t num_key = 0;
  uint32_t output_volt = 0;
  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
  /* Configure the system clock */
  SystemClock_Config();
  setup();
  /* Initialize all configured peripherals */
  GPIOA_init();

  SPI_init();
  DAC_write(0);
  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  delay_us(1000);
  //voltage = 1000;
  voltage=DAC_volts(1000);
  //DAC_write(voltage);
  //uint16_t prevVolts = 0;
  while (1)
  {
  int output = Keypad_Read(3,4); // get key value
  if (output != -1) {
	if (output > 9) {// if not int key pressed reset the values
	  num_key = 0;
	  output_volt = 0;
	  DAC_write(0);
	}
	// first key is 100 hundreds
	else if (num_key == 0) {
	  output_volt = (output * 100);
	  num_key++;
	}

	// 2nd key is 10s
	else if (num_key == 1) {
	  output_volt = output_volt + (output * 10);
	  num_key++;
	}

	// 3rd key is ones
	else { // third press write to dac and reset the values
	  output_volt = output_volt + (output);
	  uint32_t dig_val = DAC_volts((output_volt * 10)); // change to mV
	  DAC_write(dig_val);
	  output_volt = 0;
	  num_key = 0;
	}
	delay_us(500000);
  }
}
}

void GPIOA_init(void){
	// enable clock for GPIOA & SPI1
	   RCC->AHB2ENR |= (RCC_AHB2ENR_GPIOAEN);                // GPIOA: DAC NSS/SCK/SDO
	   RCC->APB2ENR |= (RCC_APB2ENR_SPI1EN);                 // SPI1 port
	   /* USER ADD GPIO configuration of MODER/PUPDR/OTYPER/OSPEEDR registers HERE */
	   // configs the registers in order: OTYPER, PUPDR, OSPEEDR, MODDER
	   GPIOA -> OTYPER &= ~(GPIO_OTYPER_OT4 | // PA4: NSS
							GPIO_OTYPER_OT5 | // PA5: SCK
							GPIO_OTYPER_OT6 | // PA6: MISO
							GPIO_OTYPER_OT7); // PA7: MOSI
	   GPIOA -> PUPDR &= ~(GPIO_PUPDR_PUPD4 |
					   	   GPIO_PUPDR_PUPD5 |
						   GPIO_PUPDR_PUPD6 |
						   GPIO_PUPDR_PUPD7); // no PUPDRs for any pins
	   GPIOA -> OSPEEDR |= ((3 << GPIO_OSPEEDR_OSPEED4_Pos) |
							(3 << GPIO_OSPEEDR_OSPEED5_Pos) |
							(3 << GPIO_OSPEEDR_OSPEED6_Pos) |
							(3 << GPIO_OSPEEDR_OSPEED7_Pos)); // maximum speed
	   GPIOA -> MODER &= ~(GPIO_MODER_MODE4 |
					   	   GPIO_MODER_MODE5 |
						   GPIO_MODER_MODE6 |
						   GPIO_MODER_MODE7); // reset the GPIO ports
	   GPIOA -> MODER |= (GPIO_MODER_MODE4_1 |
					  	  GPIO_MODER_MODE5_1 |
						  GPIO_MODER_MODE6_1 |
						  GPIO_MODER_MODE7_1); // alternate function mode

	   // configure AFR for SPI1 function (1 of 3 SPI bits shown here)
	   // For SPI, PA4-7 are all on AF5
	   GPIOA->AFR[0] &= ~((0x000F << GPIO_AFRL_AFSEL4_Pos)); // clear nibble for bit 7 AF
	   GPIOA->AFR[0] |=  ((0x0005 << GPIO_AFRL_AFSEL4_Pos)); // set b7 AF to SPI1 (fcn 5)

	   GPIOA->AFR[0] &= ~((0x000F << GPIO_AFRL_AFSEL5_Pos)); // clear nibble for bit 7 AF
	   GPIOA->AFR[0] |=  ((0x0005 << GPIO_AFRL_AFSEL5_Pos)); // set b7 AF to SPI1 (fcn 5)

	   GPIOA->AFR[0] &= ~((0x000F << GPIO_AFRL_AFSEL6_Pos)); // clear nibble for bit 7 AF
	   GPIOA->AFR[0] |=  ((0x0005 << GPIO_AFRL_AFSEL6_Pos)); // set b7 AF to SPI1 (fcn 5)

	   GPIOA->AFR[0] &= ~((0x000F << GPIO_AFRL_AFSEL7_Pos)); // clear nibble for bit 7 AF
	   GPIOA->AFR[0] |=  ((0x0005 << GPIO_AFRL_AFSEL7_Pos)); // set b7 AF to SPI1 (fcn 5
	/* USER ADD GPIO configuration of MODER/PUPDR/OTYPER/OSPEEDR registers HERE */
	// configure AFR for SPI1 function (1 of 3 SPI bits shown here)
}

void SPI_init(void){

	// SPI config as specified @ STM32L4 RM0351 rev.9 p.1459
   // called by or with DAC_init()
   // build control registers CR1 & CR2 for SPI control of peripheral DAC
   // assumes no active SPI xmits & no recv data in process (BSY=0)
   // CR1 (reset value = 0x0000)
   SPI1->CR1=(0x0000);
   SPI1->CR1 &= ~( SPI_CR1_SPE );             	// disable SPI for config
   SPI1->CR1 &= ~( SPI_CR1_RXONLY );          	// recv-only OFF
   SPI1->CR1 &= ~( SPI_CR1_LSBFIRST );        	// data bit order MSb:LSb
   SPI1->CR1 &= ~( SPI_CR1_CPOL | SPI_CR1_CPHA ); // SCLK polarity:phase = 0:0
   SPI1->CR1 |=	 SPI_CR1_MSTR;              	// MCU is SPI controller
   //SPI1->CR1 &= ~(SPI_CR1_SSM); //slave management
   //SPI1->CR1 |= SPI_CR1_SSI; //internal select as high
   // CR2 (reset value = 0x0700 : 8b data)
   SPI1->CR2 = (0x0700);
   SPI1->CR2 &= ~( SPI_CR2_TXEIE | SPI_CR2_RXNEIE ); // disable FIFO intrpts
   SPI1->CR2 &= ~( SPI_CR2_FRF);              	// Moto frame format
   SPI1->CR2 |=	 SPI_CR2_NSSP;              	// auto-generate NSS pulse
   SPI1->CR2 |=	 SPI_CR2_DS;                	// 16-bit data
   SPI1->CR2 |=	 SPI_CR2_SSOE;              	// enable SS output
   // CR1
   SPI1->CR1 |=	 SPI_CR1_SPE;               	// re-enable SPI for ops



	//SPI1->CR1 &= ~(SPI_CR1_BR);
	//SPI1->CR1 |= SPI_CR1_NSSP;

   //SPI1->CR2 |=	 (SPI_CR2_SSOE);              	// enable SS output
}

void DAC_write(uint16_t in){

  SPI1->CR1 &= ~SPI_CR1_SSI; // Clear the SSI bit, setting the NSS pin low
							 // (selected slave device)

  // check if the buffer is empty
  while (!(SPI1->SR & SPI_SR_TXE)) {
  }

  // writing to the DAC
  SPI1->DR = 0x1000 + in;
  while (SPI1->SR & SPI_SR_BSY) {
  } // Wait for the SPI bus to become idle

  SPI1->CR1 |= SPI_CR1_SSI; // Set the SSI bit, setting the NSS pin high
							// (deselect slave device)
}

uint16_t DAC_volts(uint16_t mv){ //4095 is the max value
	//mv=mv+100;
   if (mv > 3300) {
	   //mv= (3300); // account for 2x gain
	   return 3283;//(mv/2)*4095/3300;
   }
   else {
	   //return (((mv) *1.4) -0.712849); // 1x gain
	   return ((4095*mv)/3300)*0.980257+0.01222256; //bad ratio rn
   }
}
